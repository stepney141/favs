# ソースコードの問題点と修正案

本ドキュメントではプロジェクトのソースコードを分析し、問題点と具体的な修正案を提案します。
プロジェクト背景情報なしにコード自体のみを読み解いた結果を元にしています。

## 1. アーキテクチャと設計の改善

### 1.1 責務の分離

#### 問題点

- `bookmaker.ts`と`fetchers.ts`の責務が明確に分離されていない
- `index.ts`にビジネスロジックが多すぎる
- クラスとモジュールの責務境界が曖昧

#### 修正案

- **bookmaker.ts**：データ取得とブラウザ操作のみに責務を限定

  ```typescript
  // Before
  export class Bookmaker {
    // ブラウザ操作と書籍情報の取得が混在している
  }

  // After
  export class BookmeterScraper {
    // ブラウザ操作とHTMLパース処理に責務を限定
  }

  export class BookRepository {
    // データの永続化と取得に関する操作
  }
  ```

## 2. エラーハンドリングの強化

### 2.1 統一的なエラー処理

#### 問題点

- エラー処理に一貫性がない
- エラーの種類に応じた処理が不足
- 回復可能なエラーと致命的なエラーの区別がない

#### 修正案

- カスタムエラークラスの導入

  ```typescript
  // errors/index.ts
  export class AppError extends Error {
    constructor(
      message: string,
      public readonly code: string
    ) {
      super(message);
      this.name = this.constructor.name;
    }
  }

  export class ApiError extends AppError {
    constructor(
      message: string,
      public readonly statusCode: number,
      public readonly endpoint: string
    ) {
      super(message, `API_ERROR_${statusCode}`);
    }
  }

  export class ScrapingError extends AppError {
    constructor(
      message: string,
      public readonly selector: string
    ) {
      super(message, "SCRAPING_ERROR");
    }
  }
  ```

- エラー発生時の処理戦略
  ```typescript
  // services/error-handler.ts
  export class ErrorHandler {
    handle(error: unknown): void {
      if (error instanceof ApiError) {
        if (error.statusCode >= 500) {
          // サーバーエラー - リトライ
        } else if (error.statusCode === 429) {
          // レート制限 - バックオフして再試行
        } else {
          // クライアントエラー - 修正または報告
        }
      } else if (error instanceof ScrapingError) {
        // スクレイピングエラー処理
      } else {
        // 未知のエラー
        console.error("Unexpected error:", error);
      }
    }
  }
  ```

### 2.2 エラーログの改善

#### 問題点

- エラーログが文字列連結で作成されている
- コンテキスト情報が不足
- ログレベルが適切に使い分けられていない

#### 修正案

- 構造化ロギングの導入

  ```typescript
  // logger.ts
  import winston from "winston";

  export const logger = winston.createLogger({
    level: process.env.LOG_LEVEL || "info",
    format: winston.format.combine(winston.format.timestamp(), winston.format.json()),
    transports: [
      new winston.transports.Console(),
      new winston.transports.File({ filename: "error.log", level: "error" }),
      new winston.transports.File({ filename: "combined.log" })
    ]
  });
  ```

- コンテキスト情報の充実
  ```typescript
  // api-client.ts
  async function makeRequest(url: string, params: object): Promise<Response> {
    try {
      // リクエスト処理
    } catch (error) {
      logger.error("API request failed", {
        url,
        params,
        error:
          error instanceof Error
            ? {
                message: error.message,
                stack: error.stack,
                name: error.name
              }
            : String(error),
        requestId: generateRequestId()
      });
      throw error;
    }
  }
  ```

### 2.3 リトライメカニズム

#### 問題点

- 一時的な障害に対する回復戦略がない
- APIリクエストの失敗時の代替手段がない

#### 修正案

- 指数バックオフを用いたリトライ

  ```typescript
  // utils/retry.ts
  export async function withRetry<T>(fn: () => Promise<T>, options: RetryOptions = {}): Promise<T> {
    const { maxRetries = 3, initialDelay = 1000, factor = 2, jitter = 0.1 } = options;

    let attempt = 0;

    while (true) {
      try {
        return await fn();
      } catch (error) {
        attempt++;
        if (attempt >= maxRetries || !isRetryableError(error)) {
          throw error;
        }

        const delay = calculateBackoff(initialDelay, factor, attempt, jitter);
        logger.warn(`Retrying after ${delay}ms (attempt ${attempt}/${maxRetries})`, {
          error: error instanceof Error ? error.message : String(error)
        });

        await sleep(delay);
      }
    }
  }
  ```

- サーキットブレーカーパターン

  ```typescript
  // utils/circuit-breaker.ts
  export class CircuitBreaker {
    private state: "CLOSED" | "OPEN" | "HALF_OPEN" = "CLOSED";
    private failureCount = 0;
    private lastFailureTime = 0;

    constructor(
      private threshold: number = 5,
      private timeout: number = 30000
    ) {}

    async execute<T>(fn: () => Promise<T>): Promise<T> {
      if (this.state === "OPEN") {
        if (Date.now() - this.lastFailureTime >= this.timeout) {
          this.state = "HALF_OPEN";
        } else {
          throw new Error("Circuit is OPEN");
        }
      }

      try {
        const result = await fn();
        this.onSuccess();
        return result;
      } catch (error) {
        this.onFailure();
        throw error;
      }
    }

    private onSuccess(): void {
      this.failureCount = 0;
      this.state = "CLOSED";
    }

    private onFailure(): void {
      this.failureCount++;
      this.lastFailureTime = Date.now();

      if (this.state === "HALF_OPEN" || this.failureCount >= this.threshold) {
        this.state = "OPEN";
      }
    }
  }
  ```

## 3. 非同期処理の最適化

### 3.1 効率的な並行処理

#### 問題点

- `sleep()`や`randomWait()`を多用しており効率が悪い
- 直列に実行される処理が多く、全体の処理時間が長い
- 自前の`PromiseQueue`の実装が複雑

#### 修正案

- APIレート制限を考慮したスロットリング

  ```typescript
  // utils/rate-limiter.ts
  export class RateLimiter {
    private queue: Array<() => Promise<void>> = [];
    private running = false;

    constructor(
      private maxRequestsPerInterval: number = 5,
      private intervalMs: number = 1000
    ) {}

    async limit<T>(fn: () => Promise<T>): Promise<T> {
      return new Promise<T>((resolve, reject) => {
        this.queue.push(async () => {
          try {
            const result = await fn();
            resolve(result);
          } catch (error) {
            reject(error);
          }
        });

        void this.processQueue();
      });
    }

    private async processQueue(): Promise<void> {
      if (this.running) return;
      this.running = true;

      while (this.queue.length > 0) {
        const batch = this.queue.splice(0, this.maxRequestsPerInterval);
        const startTime = Date.now();

        await Promise.all(batch.map((task) => task()));

        const elapsedTime = Date.now() - startTime;
        const waitTime = Math.max(0, this.intervalMs - elapsedTime);

        if (waitTime > 0) {
          await new Promise((resolve) => setTimeout(resolve, waitTime));
        }
      }

      this.running = false;
    }
  }
  ```

- 関連しない非同期操作の並列化

  ```typescript
  // Before
  const updatedBooklist = await fetchBiblioInfo(latestBookList, {...});
  await exportFile({...});
  await crawlKinokuniya(updatedBooklist, mode);
  await saveBookListToDatabase(updatedBooklist, mode);
  await uploadDatabaseToFirebase();

  // After
  const updatedBooklist = await fetchBiblioInfo(latestBookList, {...});

  // 並列に実行可能な処理
  await Promise.all([
    exportFile({...}),
    (async () => {
      await crawlKinokuniya(updatedBooklist, mode);
      await saveBookListToDatabase(updatedBooklist, mode);
      await uploadDatabaseToFirebase();
    })()
  ]);
  ```

### 3.2 ストリーミング処理の導入

#### 問題点

- すべてのデータをメモリに読み込んでから処理している
- 大量データ処理時にメモリ効率が悪い

#### 修正案

- ストリーム処理の導入

  ```typescript
  // utils/stream.ts
  export async function* streamBookList(bookUrls: string[], batchSize: number = 10): AsyncGenerator<Book[]> {
    for (let i = 0; i < bookUrls.length; i += batchSize) {
      const batch = bookUrls.slice(i, i + batchSize);
      const books = await Promise.all(batch.map((url) => fetchBookDetails(url)));
      yield books;
    }
  }

  // 使用例
  export async function processBooksStreaming(): Promise<void> {
    const bookUrls = await getBookUrls();

    for await (const bookBatch of streamBookList(bookUrls)) {
      await processBatch(bookBatch);
      // メモリからバッチを解放
    }
  }
  ```

### 3.3 非同期フローの簡素化

#### 問題点

- 複雑なPromiseチェーンが読みにくい
- エラー処理が分散している

#### 修正案

- async/awaitの一貫した使用

  ```typescript
  // Before
  book.login().then((book) => book.explore(mode, doLogin));

  // After
  const loggedInBook = await book.login();
  const bookList = await loggedInBook.explore(mode, doLogin);
  ```

- 非同期処理の整理

  ```typescript
  // Before（複雑なネストと例外処理）
  try {
    // ...
    if (hasDifferences) {
      let updatedBooklist = latestBookList;
      if (!skipFetchingBiblioInfo) {
        try {
          updatedBooklist = await fetchBiblioInfo(latestBookList, {...});
        } catch (error) {
          console.error(`${JOB_NAME}: Error fetching bibliographic information:`, error);
        }
      } else {
        console.log(`${JOB_NAME}: Skipping bibliographic information fetch.`);
      }
      try {
        await exportFile({...})
      } catch (error) {
        console.error(`${JOB_NAME}: Error exporting file:`, error);
      }
      // ...
    }
  } catch (e) {
    // ...
  }

  // After（整理された非同期フロー）
  async function processBookList(bookList: BookList, options: ProcessOptions): Promise<void> {
    let updatedList = bookList;

    if (!options.skipFetchingBiblioInfo) {
      updatedList = await this.biblioService.fetchInfo(bookList);
    }

    await this.exportService.saveToFile(updatedList, options.outputPath);

    if (options.processExtraInfo) {
      await this.extraInfoService.process(updatedList, options.mode);
    }
  }

  // 使用
  try {
    const bookList = await this.bookRepository.getLatestBooks(mode);
    if (this.bookComparisonService.hasDifferences(prevList, bookList)) {
      await processBookList(bookList, options);
    }
  } catch (error) {
    this.errorHandler.handle(error);
    throw error;
  }
  ```

## 4. コード品質の向上

### 4.1 コードの重複排除

#### 問題点

- 似たようなAPIリクエスト処理が繰り返されている
- ログ出力パターンが重複している
- スクレイピング処理にパターンの重複がある

#### 修正案

- 共通ユーティリティ関数の抽出

  ```typescript
  // utils/api.ts
  export async function makeApiRequest<T>(url: string, options: ApiRequestOptions = {}): Promise<T> {
    const { method = "GET", headers = {}, data, timeout = 10000 } = options;

    try {
      const response = await axios({
        method,
        url,
        headers,
        data,
        timeout,
        responseType: options.responseType || "json"
      });

      return response.data;
    } catch (error) {
      handleApiError(error, url);
      throw error;
    }
  }

  // utils/scraping.ts
  export async function safeGetElement(
    page: Page,
    selector: string,
    options: ElementOptions = {}
  ): Promise<ElementHandle | null> {
    try {
      const element = await waitForXPath(page, selector, {
        timeout: options.timeout || 30000,
        visible: options.visible
      });
      return element;
    } catch (error) {
      if (options.required) {
        throw new ScrapingError(`Element not found: ${selector}`, selector);
      }
      return null;
    }
  }
  ```

- コンポジションパターンを活用

  ```typescript
  // services/api/base-api-client.ts
  export abstract class BaseApiClient {
    constructor(
      protected baseUrl: string,
      protected logger: Logger,
      protected rateLimiter: RateLimiter
    ) {}

    protected async get<T>(path: string, params?: object): Promise<T> {
      return this.rateLimiter.limit(() =>
        makeApiRequest<T>(`${this.baseUrl}${path}`, {
          method: "GET",
          params
        })
      );
    }

    // 他のHTTPメソッド...
  }

  // services/api/openbd-client.ts
  export class OpenBDClient extends BaseApiClient {
    constructor(logger: Logger, rateLimiter: RateLimiter) {
      super("https://api.openbd.jp/v1", logger, rateLimiter);
    }

    async getBookByIsbn(isbn: string): Promise<OpenBD.Response> {
      return this.get<OpenBD.Response>("/get", { isbn });
    }
  }
  ```

### 4.2 型システムの最適化

#### 問題点

- 型の定義が過剰に複雑
- Union型の使用が理解しにくい
- 型の再利用性が低い

#### 修正案

- 型の簡素化と共通化

  ```typescript
  // Before
  export type Book = {
    bookmeter_url: string;
    isbn_or_asin: ISBN10 | ASIN;
    // ... 他の多くのプロパティ
  } & {
    [key in OpacLink]: string;
  } & {
    [key in ExistIn]: "Yes" | "No";
  } & {
    sophia_mathlib_opac: string;
    description: string;
  };

  // After
  export type BaseBook = {
    bookmeter_url: string;
    isbn_or_asin: ISBN10 | ASIN;
    book_title: string;
    author: string;
    publisher: string;
    published_date: string;
    description: string;
  };

  export type LibraryAvailability = {
    [key in LibraryKey as `exist_in_${key}`]: "Yes" | "No";
  };

  export type LibraryLinks = {
    [key in LibraryKey as `${Lowercase<key>}_opac`]: string;
  };

  export type Book = BaseBook &
    LibraryAvailability &
    LibraryLinks & {
      sophia_mathlib_opac: string;
    };
  ```

- 実行時型チェックの導入

  ```typescript
  // validation/schemas.ts
  import { z } from "zod";

  export const BookSchema = z.object({
    bookmeter_url: z.string().url(),
    isbn_or_asin: z.string(),
    book_title: z.string(),
    author: z.string(),
    publisher: z.string(),
    published_date: z.string(),
    description: z.string().optional().default("")
    // その他のフィールド
  });

  export type Book = z.infer<typeof BookSchema>;

  // 検証関数
  export function validateBook(data: unknown): Book {
    return BookSchema.parse(data);
  }
  ```

### 4.3 定数と設定の整理

#### 問題点

- マジックナンバー/文字列がコード内にハードコードされている
- 環境依存の設定値が分散している
- XPATHセレクタなどが管理しにくい

#### 修正案

- マジックナンバーの定数化

  ```typescript
  // constants/timing.ts
  export const TIMEOUTS = {
    DEFAULT_PAGE_LOAD: 2 * 60 * 1000, // 2分
    ELEMENT_WAIT: 30 * 1000, // 30秒
    API_REQUEST: 10 * 1000, // 10秒
    SCRAPING_DELAY: 1500 // 1.5秒
  };

  // constants/rate-limits.ts
  export const RATE_LIMITS = {
    OPENBD: { requestsPerSecond: 10 },
    NDL: { requestsPerSecond: 5 },
    GOOGLE_BOOKS: { requestsPerSecond: 5 },
    ISBNDB: { requestsPerSecond: 2 }
  };
  ```

- 環境依存設定の集中管理

  ```typescript
  // config/index.ts
  import dotenv from "dotenv";
  import { z } from "zod";

  dotenv.config();

  const ConfigSchema = z.object({
    BOOKMETER_ACCOUNT: z.string(),
    BOOKMETER_PASSWORD: z.string(),
    CINII_API_APPID: z.string(),
    GOOGLE_BOOKS_API_KEY: z.string(),
    ISBNDB_API_KEY: z.string(),
    FIREBASE_API_KEY: z.string().optional(),
    // 他の設定
    NODE_ENV: z.enum(["development", "production", "test"]).default("development"),
    LOG_LEVEL: z.enum(["debug", "info", "warn", "error"]).default("info")
  });

  export const config = ConfigSchema.parse(process.env);
  ```

- セレクタの管理改善

  ```typescript
  // constants/selectors.ts
  export const SELECTORS = {
    bookmeter: {
      book: {
        amazonLink: {
          xpath: "//a[img[@alt='Amazon']]",
          description: "書籍ページ内のAmazonリンク"
        },
        author: {
          xpath: "//header/div[1]/ul/li",
          description: "著者情報"
        }
        // 他のセレクタ
      }
      // 他のページセレクタ
    }
  };

  // 使用例
  const amazonLinkHandle = await $x(page, SELECTORS.bookmeter.book.amazonLink.xpath);
  ```

## 5. テストとドキュメントの充実

### 5.1 テスト戦略の実装

#### 問題点

- テストコードが存在しない
- 外部依存（API、スクレイピング）のテストが困難
- 複雑なロジックの正確性が検証されていない

#### 修正案

- 単体テスト導入

  ```typescript
  // tests/unit/utils.test.ts
  import { expect } from "chai";
  import { convertISBN10To13, isIsbn10, matchASIN } from "../../src/utils";

  describe("ISBN Utilities", () => {
    describe("isIsbn10", () => {
      it("should return true for valid ISBN-10", () => {
        expect(isIsbn10("4062584867")).to.be.true;
      });

      it("should return false for invalid ISBN-10", () => {
        expect(isIsbn10("123456789")).to.be.false;
      });

      it("should return false for ISBN-13", () => {
        expect(isIsbn10("9784062584869")).to.be.false;
      });
    });

    describe("convertISBN10To13", () => {
      it("should correctly convert ISBN-10 to ISBN-13", () => {
        expect(convertISBN10To13("4062584867")).to.equal("9784062584869");
      });
    });
  });
  ```

- 統合テスト

  ```typescript
  // tests/integration/biblioinfo.test.ts
  import { expect } from "chai";
  import sinon from "sinon";
  import axios from "axios";
  import { fetchBiblioInfo } from "../../src/fetchers";

  describe("BiblioInfo Service Integration", () => {
    let bookList;
    let axiosStub;

    beforeEach(() => {
      bookList = new Map();
      bookList.set("https://bookmeter.com/books/12345", {
        bookmeter_url: "https://bookmeter.com/books/12345",
        isbn_or_asin: "4062584867",
        book_title: "",
        author: "",
        publisher: "",
        published_date: ""
        // 他の必要なフィールド
      });

      axiosStub = sinon.stub(axios, "request");
    });

    afterEach(() => {
      axiosStub.restore();
    });

    it("should fetch book info from OpenBD", async () => {
      // OpenBDのレスポンスをモック
      axiosStub.resolves({
        data: [{ summary: { title: "テスト書籍", author: "テスト著者" } }]
      });

      const result = await fetchBiblioInfo(bookList, {
        cinii: "test-key",
        google: "test-key",
        isbnDb: "test-key"
      });

      const updatedBook = result.get("https://bookmeter.com/books/12345");
      expect(updatedBook.book_title).to.equal("テスト書籍");
      expect(updatedBook.author).to.equal("テスト著者");
    });
  });
  ```

- モック/スタブを活用した外部依存の分離

  ```typescript
  // tests/mocks/puppeteer.ts
  export class MockPage {
    url() {
      return "https://bookmeter.com/books/12345";
    }

    async goto(url) {
      /* 実装 */
    }

    async setRequestInterception(value) {
      /* 実装 */
    }

    async waitForXPath(selector, options) {
      // テストデータに基づいて要素を返す
      return {
        type: async () => {},
        click: async () => {}
      };
    }

    // 他のメソッド
  }

  export class MockBrowser {
    async newPage() {
      return new MockPage();
    }

    async close() {}
  }
  ```

### 5.2 ドキュメントの強化

#### 問題点

- JSDocが不足している
- アーキテクチャやデータフローの説明がない
- README.mdなどのプロジェクト概要ドキュメントが不十分

#### 修正案

- 包括的なJSDocの追加

  ```typescript
  /**
   * 書籍の書誌情報を取得するサービス
   *
   * 複数のAPIを使用して書籍の情報を取得し、統合します。
   * 主に以下のAPIを利用します:
   * - OpenBD: 和書の書誌情報
   * - NDL: 国立国会図書館の書誌情報
   * - GoogleBooks: 洋書を含む幅広い書籍情報
   * - ISBNdb: ISBNに基づく書籍検索
   *
   * @example
   * const service = new BiblioInfoService(credentials);
   * const bookInfo = await service.fetchInfo('9784062584869');
   */
  export class BiblioInfoService {
    // 実装
  }

  /**
   * ISBN-10をISBN-13に変換します
   *
   * ISBN-10の先頭に接頭辞"978"を追加し、チェックディジットを再計算します
   *
   * @param isbn10 - 変換するISBN-10
   * @returns 変換されたISBN-13
   * @throws {Error} 無効なISBN-10が指定された場合
   */
  export function convertISBN10To13(isbn10: ISBN10): ISBN13 {
    // 実装
  }
  ```

- アーキテクチャ図とデータフロー図の作成

  ````markdown
  # アーキテクチャ概要

  ```mermaid
  graph TD
    A[Bookmaker] --> B[ISBNリスト取得]
    B --> C[書誌情報API]
    C --> D[データ保存]
    D --> E[SQLite DB]
    D --> F[CSVファイル]
    E --> G[Firebase Storage]
  ```
  ````

  ## データフロー

  1. Bookmeterからユーザーの読みたい本/積読本リストを取得
  2. 各書籍のISBNを抽出
  3. 複数のAPIから書誌情報を取得
  4. データを統合
  5. CSVとSQLiteに保存
  6. SQLiteファイルをFirebaseにアップロード

  ```

  ```

- プロジェクト概要ドキュメントの充実

  ```markdown
  # Bookmeter Crawler

  ## 概要

  このプロジェクトは、Bookmeter(読書メーター)から特定ユーザーの読みたい本/積読本リストを取得し、
  各書籍の詳細情報を複数のAPIから収集して保存するためのツールです。

  ## 特徴

  - Bookmeterからの読書リスト自動取得
  - 複数の書誌情報API連携 (OpenBD, NDL, GoogleBooks, ISBNdb)
  - 図書館所蔵情報の取得 (CiNii経由)
  - データをCSVおよびSQLite形式で保存
  - Firebase Storageとの同期

  ## セットアップ

  1. 依存パッケージのインストール: `npm install`
  2. 環境変数の設定: `.env`ファイルを作成し、必要なAPI鍵を設定
  3. 実行: `npx tsx index.ts wish` または `npx tsx index.ts stacked`

  ## API鍵の取得方法

  - OpenBD: API鍵は不要
  - NDL: [国立国会図書館サーチ](https://iss.ndl.go.jp/)からアカウント登録
  - GoogleBooks: [Google Cloud Console](https://console.cloud.google.com/)からAPI鍵を取得
  - ISBNdb: [ISBNdb](https://isbndb.com/)で有料アカウント登録
  ```

## 6. セキュリティの強化

### 6.1 機密情報の管理

#### 問題点

- 環境変数を使用しているが、適切なバリデーションがない
- Firebaseの認証情報など、重要な情報の管理が不十分
- シークレットの露出リスクがある

#### 修正案

- 環境変数のバリデーション

  ```typescript
  // config/environment.ts
  import { z } from "zod";
  import dotenv from "dotenv";

  // .envファイルを読み込む
  dotenv.config();

  // 環境変数のスキーマ定義
  const envSchema = z.object({
    // 必須の環境変数
    BOOKMETER_ACCOUNT: z.string().min(1, "BOOKMETERアカウントが必要です"),
    BOOKMETER_PASSWORD: z.string().min(8, "BOOKMETERパスワードは8文字以上必要です"),

    // API鍵（必須）
    CINII_API_APPID: z.string().min(1, "CiNii API APPIDが必要です"),
    GOOGLE_BOOKS_API_KEY: z.string().min(1, "Google Books API Keyが必要です"),

    // オプションの環境変数
    ISBNDB_API_KEY: z.string().optional(),

    // Firebase関連（全て必須）
    FIREBASE_API_KEY: z.string().min(1),
    FIREBASE_AUTH_DOMAIN: z.string().min(1),
    FIREBASE_PROJECT_ID: z.string().min(1),
    FIREBASE_STORAGE_BUCKET: z.string().min(1),
    FIREBASE_MESSAGING_SENDER_ID: z.string().min(1),
    FIREBASE_APP_ID: z.string().min(1),

    // ノード環境
    NODE_ENV: z.enum(["development", "production", "test"]).default("development")
  });

  // 環境変数の検証と型付け
  export const env = envSchema.parse(process.env);

  // 使用例
  // import { env } from './config/environment';
  // console.log(env.BOOKMETER_ACCOUNT); // 型安全で値の存在が保証されている
  ```

- シークレットマネージャーの導入

  ```typescript
  // services/secret-manager.ts
  import { SecretManagerServiceClient } from "@google-cloud/secret-manager";

  export class SecretManager {
    private client: SecretManagerServiceClient;
    private projectId: string;
    private cache: Map<string, { value: string; expiresAt: number }> = new Map();

    constructor(projectId: string) {
      this.client = new SecretManagerServiceClient();
      this.projectId = projectId;
    }

    async getSecret(secretName: string, ttlMs: number = 3600000): Promise<string> {
      const cacheKey = `${this.projectId}/${secretName}`;
      const cached = this.cache.get(cacheKey);

      // キャッシュがあり、有効期限内なら使用
      if (cached && cached.expiresAt > Date.now()) {
        return cached.value;
      }

      // シークレットを取得
      const [version] = await this.client.accessSecretVersion({
        name: `projects/${this.projectId}/secrets/${secretName}/versions/latest`
      });

      if (!version.payload || !version.payload.data) {
        throw new Error(`Secret ${secretName} not found or empty`);
      }

      const secretValue = version.payload.data.toString();

      // キャッシュを更新
      this.cache.set(cacheKey, {
        value: secretValue,
        expiresAt: Date.now() + ttlMs
      });

      return secretValue;
    }
  }

  // 使用例
  // const secretManager = new SecretManager('my-project-id');
  // const apiKey = await secretManager.getSecret('api-key-name');
  ```

- HTTPS通信の強制

  ```typescript
  // services/api-client.ts
  import axios, { AxiosRequestConfig, AxiosResponse } from "axios";

  export class SecureApiClient {
    private baseUrl: string;

    constructor(baseUrl: string) {
      // URLがHTTPSで始まることを確認
      if (!baseUrl.startsWith("https://") && process.env.NODE_ENV === "production") {
        throw new Error("Production環境ではHTTPS URLのみ許可されています");
      }
      this.baseUrl = baseUrl;
    }

    async request<T>(config: AxiosRequestConfig): Promise<T> {
      try {
        const response: AxiosResponse<T> = await axios({
          ...config,
          url: `${this.baseUrl}${config.url}`,
          // 機密情報をURLに含めない
          params: this.sanitizeParams(config.params)
        });

        return response.data;
      } catch (error) {
        // エラーハンドリング
        throw error;
      }
    }

    // URLパラメータから機密情報を削除
    private sanitizeParams(params?: Record<string, any>): Record<string, any> | undefined {
      if (!params) return params;

      const sanitized = { ...params };
      const sensitiveKeys = ["password", "token", "api_key", "apiKey", "secret"];

      sensitiveKeys.forEach((key) => {
        if (key in sanitized) {
          delete sanitized[key];
        }
      });

      return sanitized;
    }
  }
  ```

### 6.2 データ検証の欠如

#### 問題点

- 外部から取得したデータの検証が不十分
- 特にスクレイピングデータの整合性チェックが弱い
- 悪意あるデータやAPI応答の変更に対する脆弱性

#### 修正案

- スクレイピングデータの検証強化

  ```typescript
  // services/data-validator.ts
  import { z } from "zod";
  import { Book } from "../domain/entities/book";

  export class DataValidator {
    // スクレイピングで取得した書籍データのバリデーション
    static validateScrapedBook(data: unknown): Partial<Book> {
      const ScrapedBookSchema = z.object({
        bookmeter_url: z.string().url(),
        isbn_or_asin: z.string().regex(/^([0-9]{9}[0-9X]|[A-Z0-9]{10})$/),
        book_title: z.string().min(1),
        author: z.string().optional()
      });

      return ScrapedBookSchema.parse(data);
    }

    // APIレスポンスのバリデーション（OpenBD用）
    static validateOpenBDResponse(data: unknown): boolean {
      try {
        const OpenBDResponseSchema = z.array(
          z
            .object({
              summary: z
                .object({
                  isbn: z.string(),
                  title: z.string(),
                  volume: z.string().optional(),
                  series: z.string().optional(),
                  publisher: z.string().optional(),
                  pubdate: z.string().optional(),
                  cover: z.string().url().optional(),
                  author: z.string().optional()
                })
                .optional()
            })
            .nullable()
        );

        OpenBDResponseSchema.parse(data);
        return true;
      } catch (error) {
        console.error("OpenBD response validation failed:", error);
        return false;
      }
    }

    // CSVデータの検証
    static validateCSVRow(row: Record<string, string>): Partial<Book> {
      const CSVRowSchema = z.object({
        bookmeter_url: z.string().url(),
        isbn_or_asin: z.string(),
        book_title: z.string().min(1),
        author: z.string().optional().default(""),
        publisher: z.string().optional().default(""),
        published_date: z.string().optional().default("")
      });

      return CSVRowSchema.parse(row);
    }

    // 入力値のサニタイズ
    static sanitizeString(input: string): string {
      // HTMLタグの除去
      let sanitized = input.replace(/<[^>]*>/g, "");

      // 改行文字の正規化
      sanitized = sanitized.replace(/\r\n|\r/g, "\n");

      // XSS対策：スクリプトタグ内のコンテンツを削除
      sanitized = sanitized.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, "");

      return sanitized.trim();
    }
  }
  ```

- APIレスポンスの検証と型付け

  ```typescript
  // services/api/openbd-client.ts
  import { z } from "zod";
  import { makeApiRequest } from "../../utils/api";
  import { logger } from "../../utils/logger";

  // レスポンス型の定義とパーサー
  const OpenBDSummarySchema = z.object({
    isbn: z.string(),
    title: z.string(),
    volume: z.string().optional(),
    series: z.string().optional(),
    publisher: z.string().optional(),
    pubdate: z.string().optional(),
    cover: z.string().url().optional(),
    author: z.string().optional()
  });

  const OpenBDItemSchema = z
    .object({
      summary: OpenBDSummarySchema.optional(),
      onix: z.any().optional()
    })
    .nullable();

  const OpenBDResponseSchema = z.array(OpenBDItemSchema);

  type OpenBDResponse = z.infer<typeof OpenBDResponseSchema>;

  export class OpenBDClient {
    private baseUrl = "https://api.openbd.jp/v1";

    async getBookByIsbn(isbn: string): Promise<OpenBDResponse> {
      try {
        const data = await makeApiRequest(`${this.baseUrl}/get`, {
          method: "GET",
          params: { isbn }
        });

        // レスポンスの検証
        const validatedData = OpenBDResponseSchema.parse(data);
        return validatedData;
      } catch (error) {
        if (error instanceof z.ZodError) {
          // バリデーションエラー
          logger.error("OpenBD response schema validation failed", {
            isbn,
            error: error.format()
          });
          throw new Error(`OpenBD API response validation failed: ${error.message}`);
        }

        // その他のエラー
        throw error;
      }
    }
  }
  ```

- WebスクレイピングのCSRF対策

  ```typescript
  // services/scraping/scraper.ts
  import { Page } from "puppeteer";
  import { logger } from "../../utils/logger";

  export class SecureScraper {
    // スクレイピングセッションの保護
    async setupSecureSession(page: Page): Promise<void> {
      // Cookieを保持
      const cookies = await page.cookies();

      // CSRFトークンの抽出
      const csrfToken = await page.evaluate(() => {
        const metaTag = document.querySelector('meta[name="csrf-token"]');
        return metaTag ? metaTag.getAttribute("content") : null;
      });

      if (!csrfToken) {
        logger.warn("CSRF token not found in page");
      }

      // ユーザーエージェントの設定
      await page.setUserAgent(
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
      );

      // ヘッダーの設定
      await page.setExtraHTTPHeaders({
        "Accept-Language": "ja-JP,ja;q=0.9,en-US;q=0.8,en;q=0.7",
        Referer: "https://bookmeter.com/",
        ...(csrfToken ? { "X-CSRF-Token": csrfToken } : {})
      });

      // ブラウザの指紋対策
      await page.evaluateOnNewDocument(() => {
        // WebRTCの無効化
        const originalRTCPeerConnection = window.RTCPeerConnection;
        window.RTCPeerConnection = function (...args) {
          const pc = new originalRTCPeerConnection(...args);
          pc.createDataChannel = function () {
            return {};
          };
          return pc;
        };

        // キャンバスフィンガープリント対策
        const originalToDataURL = HTMLCanvasElement.prototype.toDataURL;
        HTMLCanvasElement.prototype.toDataURL = function (type) {
          if (type === "image/png" && this.width === 16 && this.height === 16) {
            return "data:image/png;base64,iVBORw0KGgoAAAANSUh..."; // 固定値
          }
          return originalToDataURL.apply(this, arguments);
        };
      });
    }
  }
  ```

- **fetchers.ts**：複数のAPIクライアントを個別のクラスに分割

  ```typescript
  // Before
  export async function fetchBiblioInfo(/* ... */) {
    // OpenBD, ISBNdb, CiNii, NDL APIなど、複数のAPIが混在
  }

  // After
  export class OpenBDClient {
    async fetchBookInfo(isbn: string): Promise<BookInfo> {
      /* ... */
    }
  }

  export class NDLClient {
    async fetchBookInfo(isbn: string): Promise<BookInfo> {
      /* ... */
    }
  }

  // 集約クラス
  export class BiblioInfoService {
    constructor(
      private openBDClient: OpenBDClient,
      private ndlClient: NDLClient
      // 他のAPIクライアント
    ) {}

    async fetchCompleteBookInfo(book: Book): Promise<Book> {
      /* ... */
    }
  }
  ```

- **index.ts**：オーケストレーションのみを担当するよう改善

  ```typescript
  // Before
  export async function main(/* ... */) {
    // ブラウザ操作、データ取得、書誌情報取得、ファイル出力など多くの責務
  }

  // After
  export async function main(options: MainFuncOption) {
    const orchestrator = new BookDataOrchestrator(
      new BookmeterScraper(),
      new BiblioInfoService(/* ... */),
      new BookDataExporter()
    );

    await orchestrator.execute(options);
  }
  ```

## 7. パフォーマンスとスケーラビリティの改善

### 7.1 非効率なリソース使用

#### 問題点

- Puppeteerのインスタンスが効率的に管理されていない
- メモリ使用量の考慮が足りない（特に大量のデータ処理時）
- CPU負荷が高い処理の最適化がされていない

#### 修正案

- Puppeteerインスタンスの管理最適化

  ```typescript
  // services/browser-pool.ts
  import puppeteer, { Browser, PuppeteerLaunchOptions } from "puppeteer";
  import { logger } from "../utils/logger";

  export class BrowserPool {
    private pool: Browser[] = [];
    private inUse: Set<Browser> = new Set();
    private maxSize: number;
    private launchOptions: PuppeteerLaunchOptions;

    constructor(maxSize: number = 3, launchOptions: PuppeteerLaunchOptions = {}) {
      this.maxSize = maxSize;
      this.launchOptions = {
        defaultViewport: { width: 1000, height: 1000 },
        headless: true,
        args: [
          "--no-sandbox",
          "--disable-setuid-sandbox",
          "--disable-dev-shm-usage",
          "--disable-accelerated-2d-canvas",
          "--disable-gpu",
          "--window-size=1000,1000"
        ],
        ...launchOptions
      };
    }

    async acquire(): Promise<Browser> {
      // 使用可能なブラウザを探す
      let browser = this.pool.find((b) => !this.inUse.has(b));

      // 使用可能なブラウザがない場合、新しく作成するか待機
      if (!browser) {
        if (this.pool.length < this.maxSize) {
          // 新しいブラウザを作成
          browser = await puppeteer.launch(this.launchOptions);
          this.pool.push(browser);
        } else {
          // 使用中のインスタンスが返却されるまで待機
          logger.info("Browser pool at capacity, waiting for an available browser");
          browser = await this.waitForAvailableBrowser();
        }
      }

      // ブラウザを使用中としてマーク
      this.inUse.add(browser);
      return browser;
    }

    release(browser: Browser): void {
      if (this.inUse.has(browser)) {
        this.inUse.delete(browser);
      }
    }

    async waitForAvailableBrowser(): Promise<Browser> {
      return new Promise<Browser>((resolve) => {
        const checkInterval = setInterval(() => {
          const browser = this.pool.find((b) => !this.inUse.has(b));
          if (browser) {
            clearInterval(checkInterval);
            resolve(browser);
          }
        }, 500);
      });
    }

    async closeAll(): Promise<void> {
      for (const browser of this.pool) {
        try {
          await browser.close();
        } catch (error) {
          logger.error("Error closing browser:", error);
        }
      }
      this.pool = [];
      this.inUse.clear();
      logger.info("All browsers in the pool have been closed");
    }
  }

  // 使用例
  // const browserPool = new BrowserPool();
  // const browser = await browserPool.acquire();
  // // ブラウザ操作
  // browserPool.release(browser);
  // await browserPool.closeAll(); // アプリケーション終了時
  ```

- メモリ使用量の監視と制御

  ```typescript
  // utils/memory-monitor.ts
  import { EventEmitter } from "events";
  import { logger } from "./logger";

  export class MemoryMonitor extends EventEmitter {
    private maxMemoryUsageMB: number;
    private checkIntervalMs: number;
    private intervalId: NodeJS.Timeout | null = null;

    constructor(maxMemoryUsageMB = 1024, checkIntervalMs = 5000) {
      super();
      this.maxMemoryUsageMB = maxMemoryUsageMB;
      this.checkIntervalMs = checkIntervalMs;
    }

    start(): void {
      if (this.intervalId !== null) {
        return;
      }

      this.intervalId = setInterval(() => {
        const memoryUsage = process.memoryUsage();
        const heapUsedMB = Math.round(memoryUsage.heapUsed / 1024 / 1024);
        const rssUsedMB = Math.round(memoryUsage.rss / 1024 / 1024);

        logger.debug("Memory usage", {
          heapUsedMB,
          rssUsedMB,
          totalHeapMB: Math.round(memoryUsage.heapTotal / 1024 / 1024)
        });

        if (rssUsedMB > this.maxMemoryUsageMB) {
          this.emit("memory-warning", {
            currentUsageMB: rssUsedMB,
            maxMemoryUsageMB: this.maxMemoryUsageMB
          });

          // メモリが非常に高い場合、GCを強制実行
          if (rssUsedMB > this.maxMemoryUsageMB * 1.5 && global.gc) {
            logger.warn(`Forcing garbage collection. Memory usage: ${rssUsedMB}MB`);
            global.gc();
          }
        }
      }, this.checkIntervalMs);
    }

    stop(): void {
      if (this.intervalId !== null) {
        clearInterval(this.intervalId);
        this.intervalId = null;
      }
    }
  }

  // 使用例
  // const memoryMonitor = new MemoryMonitor();
  // memoryMonitor.on('memory-warning', ({ currentUsageMB }) => {
  //   console.log(`Memory warning: ${currentUsageMB}MB in use`);
  //   // メモリ使用量を減らすための処理
  // });
  // memoryMonitor.start();
  ```

- バッチ処理の最適化

  ```typescript
  // services/batch-processor.ts
  import { logger } from "../utils/logger";

  export class BatchProcessor<T, R> {
    private processor: (items: T[]) => Promise<R[]>;
    private batchSize: number;
    private concurrency: number;

    constructor(processor: (items: T[]) => Promise<R[]>, batchSize = 10, concurrency = 2) {
      this.processor = processor;
      this.batchSize = batchSize;
      this.concurrency = concurrency;
    }

    // バッチに分割して処理
    async process(items: T[]): Promise<R[]> {
      const batches: T[][] = [];

      // アイテムをバッチに分割
      for (let i = 0; i < items.length; i += this.batchSize) {
        batches.push(items.slice(i, i + this.batchSize));
      }

      logger.info(`Processing ${items.length} items in ${batches.length} batches`);

      const results: R[] = [];

      // 同時実行数を制御しながらバッチを処理
      for (let i = 0; i < batches.length; i += this.concurrency) {
        const currentBatches = batches.slice(i, i + this.concurrency);
        const batchPromises = currentBatches.map((batch) => this.processor(batch));

        logger.debug(`Processing batches ${i + 1} to ${i + currentBatches.length} of ${batches.length}`);

        const batchResults = await Promise.all(batchPromises);
        results.push(...batchResults.flat());
      }

      return results;
    }
  }

  // 使用例
  // const batchProcessor = new BatchProcessor<string, Book>(
  //   async (urls) => {
  //     // URLのバッチから書籍情報を取得する処理
  //     return await Promise.all(urls.map(url => fetchBookInfo(url)));
  //   },
  //   20, // バッチサイズ
  //   3   // 同時実行数
  // );
  // const books = await batchProcessor.process(bookUrls);
  ```

### 7.2 キャッシュの欠如

#### 問題点

- APIリクエスト結果のキャッシュ機構がない
- 重複データの再取得が多い
- 同じ計算が繰り返し行われている

#### 修正案

- APIレスポンスキャッシュの実装

  ```typescript
  // services/api-cache.ts
  import fs from "fs/promises";
  import path from "path";
  import crypto from "crypto";
  import { logger } from "../utils/logger";

  interface CacheEntry<T> {
    data: T;
    timestamp: number;
    expires: number;
  }

  export class ApiCache<T> {
    private cacheDir: string;
    private ttlMs: number;
    private memoryCache: Map<string, CacheEntry<T>> = new Map();

    constructor(cacheDir: string, ttlMs = 24 * 60 * 60 * 1000) {
      this.cacheDir = cacheDir;
      this.ttlMs = ttlMs;
    }

    async get(key: string): Promise<T | null> {
      // まずメモリキャッシュをチェック
      const memEntry = this.memoryCache.get(key);
      if (memEntry && memEntry.expires > Date.now()) {
        logger.debug(`Cache hit (memory): ${key}`);
        return memEntry.data;
      }

      // ディスクキャッシュをチェック
      const cacheFile = this.getCacheFilePath(key);

      try {
        const data = await fs.readFile(cacheFile, "utf-8");
        const entry = JSON.parse(data) as CacheEntry<T>;

        if (entry.expires > Date.now()) {
          // 有効なキャッシュエントリが見つかった
          logger.debug(`Cache hit (disk): ${key}`);

          // メモリキャッシュも更新
          this.memoryCache.set(key, entry);

          return entry.data;
        }

        // 期限切れのキャッシュを削除
        await fs.unlink(cacheFile);
        return null;
      } catch (error) {
        // キャッシュファイルがないか読み取れない
        return null;
      }
    }

    async set(key: string, data: T): Promise<void> {
      const now = Date.now();
      const entry: CacheEntry<T> = {
        data,
        timestamp: now,
        expires: now + this.ttlMs
      };

      // メモリキャッシュを更新
      this.memoryCache.set(key, entry);

      // ディスクキャッシュを更新
      try {
        await fs.mkdir(this.cacheDir, { recursive: true });
        const cacheFile = this.getCacheFilePath(key);
        await fs.writeFile(cacheFile, JSON.stringify(entry));
        logger.debug(`Cache set: ${key}`);
      } catch (error) {
        logger.error(`Failed to write cache for key ${key}:`, error);
      }
    }

    async invalidate(key: string): Promise<void> {
      // メモリキャッシュから削除
      this.memoryCache.delete(key);

      // ディスクキャッシュから削除
      try {
        const cacheFile = this.getCacheFilePath(key);
        await fs.unlink(cacheFile);
        logger.debug(`Cache invalidated: ${key}`);
      } catch (error) {
        // ファイルが存在しない場合は無視
      }
    }

    private getCacheFilePath(key: string): string {
      const hash = crypto.createHash("md5").update(key).digest("hex");
      return path.join(this.cacheDir, `${hash}.json`);
    }
  }

  // 使用例
  // const apiCache = new ApiCache<OpenBD.Response>('./cache/openbd');
  // // キャッシュから取得を試みる
  // let data = await apiCache.get(isbn);
  // if (!data) {
  //   // キャッシュになければAPIから取得
  //   data = await fetchFromOpenBD(isbn);
  //   await apiCache.set(isbn, data);
  // }
  ```

- メモ化（計算結果のキャッシュ）

  ```typescript
  // utils/memoize.ts
  type MemoizedFunction<T extends (...args: any[]) => any> = {
    (...args: Parameters<T>): ReturnType<T>;
    cache: Map<string, ReturnType<T>>;
    clear: () => void;
  };

  export function memoize<T extends (...args: any[]) => any>(
    fn: T,
    keyGenerator?: (...args: Parameters<T>) => string
  ): MemoizedFunction<T> {
    const cache = new Map<string, ReturnType<T>>();

    const memoized = ((...args: Parameters<T>): ReturnType<T> => {
      const key = keyGenerator ? keyGenerator(...args) : JSON.stringify(args);

      if (cache.has(key)) {
        return cache.get(key)!;
      }

      const result = fn(...args);

      // Promiseの場合は、解決後にキャッシュに保存
      if (result instanceof Promise) {
        return result.then((value) => {
          cache.set(key, value as ReturnType<T>);
          return value;
        }) as ReturnType<T>;
      }

      cache.set(key, result);
      return result;
    }) as MemoizedFunction<T>;

    memoized.cache = cache;
    memoized.clear = () => cache.clear();

    return memoized;
  }

  // 使用例
  // const expensiveCalculation = (a: number, b: number): number => {
  //   console.log('Calculating...');
  //   return a + b;
  // };
  //
  // const memoizedCalculation = memoize(expensiveCalculation);
  //
  // memoizedCalculation(1, 2); // 「Calculating...」と出力され、3を返す
  // memoizedCalculation(1, 2); // 何も出力されず、キャッシュから3を返す
  ```

- データベース接続プール

  ```typescript
  // services/db-pool.ts
  import sqlite3 from "sqlite3";
  import { open, Database } from "sqlite";
  import { logger } from "../utils/logger";

  export class DatabasePool {
    private pool: Database[] = [];
    private inUse: Set<Database> = new Set();
    private maxSize: number;
    private dbPath: string;

    constructor(dbPath: string, maxSize = 3) {
      this.dbPath = dbPath;
      this.maxSize = maxSize;
    }

    async acquire(): Promise<Database> {
      // 使用可能なコネクションを探す
      let db = this.pool.find((conn) => !this.inUse.has(conn));

      // 使用可能なコネクションがない場合、新しく作成するか待機
      if (!db) {
        if (this.pool.length < this.maxSize) {
          // 新しいコネクションを作成
          db = await open({
            filename: this.dbPath,
            driver: sqlite3.Database
          });
          this.pool.push(db);
        } else {
          // 使用中のコネクションが返却されるまで待機
          logger.info("Database pool at capacity, waiting for an available connection");
          db = await this.waitForAvailableConnection();
        }
      }

      // コネクションを使用中としてマーク
      this.inUse.add(db);
      return db;
    }

    release(db: Database): void {
      if (this.inUse.has(db)) {
        this.inUse.delete(db);
      }
    }

    async waitForAvailableConnection(): Promise<Database> {
      return new Promise<Database>((resolve) => {
        const checkInterval = setInterval(() => {
          const db = this.pool.find((conn) => !this.inUse.has(conn));
          if (db) {
            clearInterval(checkInterval);
            resolve(db);
          }
        }, 100);
      });
    }

    async closeAll(): Promise<void> {
      for (const db of this.pool) {
        try {
          await db.close();
        } catch (error) {
          logger.error("Error closing database connection:", error);
        }
      }
      this.pool = [];
      this.inUse.clear();
    }
  }

  // 使用例
  // const dbPool = new DatabasePool('./books.sqlite');
  // const db = await dbPool.acquire();
  // // データベース操作
  // dbPool.release(db);
  // await dbPool.closeAll(); // アプリケーション終了時
  ```

### 7.3 監視と可観測性の向上

#### 問題点

- アプリケーションの動作状況を把握する方法がない
- パフォーマンスのボトルネックを特定しにくい
- エラーの発生状況を追跡できない

#### 修正案

- メトリクス収集基盤の導入

  ```typescript
  // monitoring/metrics.ts
  import { EventEmitter } from "events";

  export interface MetricValue {
    value: number;
    timestamp: number;
    labels?: Record<string, string>;
  }

  export class MetricsCollector extends EventEmitter {
    private metrics: Map<string, MetricValue[]> = new Map();
    private gauges: Map<string, number> = new Map();

    // カウンタメトリック（累積値）
    increment(name: string, value: number = 1, labels?: Record<string, string>): void {
      const metricValues = this.metrics.get(name) || [];
      metricValues.push({
        value,
        timestamp: Date.now(),
        labels
      });
      this.metrics.set(name, metricValues);
      this.emit("metric", { name, type: "counter", value, labels });
    }

    // ゲージメトリック（現在値）
    gauge(name: string, value: number, labels?: Record<string, string>): void {
      this.gauges.set(name, value);
      this.emit("metric", { name, type: "gauge", value, labels });
    }

    // ヒストグラムメトリック（分布）
    histogram(name: string, value: number, labels?: Record<string, string>): void {
      const metricValues = this.metrics.get(name) || [];
      metricValues.push({
        value,
        timestamp: Date.now(),
        labels
      });
      this.metrics.set(name, metricValues);
      this.emit("metric", { name, type: "histogram", value, labels });
    }

    // タイマーメトリック（処理時間）
    startTimer(name: string, labels?: Record<string, string>): () => void {
      const startTime = Date.now();
      return () => {
        const duration = Date.now() - startTime;
        this.histogram(name, duration, labels);
      };
    }

    getMetric(name: string): MetricValue[] {
      return this.metrics.get(name) || [];
    }

    getGauge(name: string): number {
      return this.gauges.get(name) || 0;
    }

    getAllMetrics(): Record<string, MetricValue[]> {
      const result: Record<string, MetricValue[]> = {};
      for (const [name, values] of this.metrics.entries()) {
        result[name] = values;
      }
      return result;
    }

    getAllGauges(): Record<string, number> {
      const result: Record<string, number> = {};
      for (const [name, value] of this.gauges.entries()) {
        result[name] = value;
      }
      return result;
    }
  }

  // シングルトンインスタンス
  export const metrics = new MetricsCollector();

  // 使用例
  // // API呼び出しをカウント
  // metrics.increment('api_calls', 1, { api: 'openbd' });
  //
  // // メモリ使用量を記録
  // metrics.gauge('memory_usage_mb', process.memoryUsage().rss / 1024 / 1024);
  //
  // // 処理時間を計測
  // const endTimer = metrics.startTimer('fetch_duration', { source: 'bookmeter' });
  // await fetchData();
  // endTimer(); // 計測終了
  ```

- アプリケーションヘルスエンドポイント

  ```typescript
  // monitoring/health.ts
  import express from "express";
  import { MetricsCollector, metrics } from "./metrics";
  import { logger } from "../utils/logger";

  export function setupHealthMonitoring(app: express.Application): void {
    // ヘルスチェックエンドポイント
    app.get("/health", (req, res) => {
      res.status(200).json({
        status: "UP",
        timestamp: new Date().toISOString(),
        uptime: process.uptime()
      });
    });

    // 詳細ヘルスチェックエンドポイント
    app.get("/health/details", (req, res) => {
      const memoryUsage = process.memoryUsage();

      res.status(200).json({
        status: "UP",
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        memory: {
          rss: Math.round(memoryUsage.rss / 1024 / 1024),
          heapTotal: Math.round(memoryUsage.heapTotal / 1024 / 1024),
          heapUsed: Math.round(memoryUsage.heapUsed / 1024 / 1024),
          external: Math.round(memoryUsage.external / 1024 / 1024)
        }
      });
    });

    // メトリクスエンドポイント
    app.get("/metrics", (req, res) => {
      res.status(200).json({
        counters: metrics.getAllMetrics(),
        gauges: metrics.getAllGauges()
      });
    });

    // サーバー起動
    const port = process.env.HEALTH_PORT || 3001;
    app.listen(port, () => {
      logger.info(`Health monitoring server running on port ${port}`);
    });
  }

  // 使用例
  // import express from 'express';
  // import { setupHealthMonitoring } from './monitoring/health';
  //
  // const app = express();
  // setupHealthMonitoring(app);
  ```

- パフォーマンス計測と分析

  ```typescript
  // monitoring/performance.ts
  import { performance, PerformanceObserver } from "perf_hooks";
  import { metrics } from "./metrics";
  import { logger } from "../utils/logger";

  export class PerformanceMonitor {
    private observers: PerformanceObserver[] = [];

    constructor() {
      this.setupObservers();
    }

    private setupObservers(): void {
      // 関数実行時間の監視
      const funcObserver = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          metrics.histogram("function_duration", entry.duration, {
            name: entry.name
          });

          // 長時間実行の関数を警告
          if (entry.duration > 1000) {
            logger.warn(`Slow function execution: ${entry.name} took ${entry.duration.toFixed(2)}ms`);
          }
        }
      });
      funcObserver.observe({ entryTypes: ["function"], buffered: true });
      this.observers.push(funcObserver);

      // HTTPリクエストの監視
      const httpObserver = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          metrics.histogram("http_request_duration", entry.duration, {
            url: entry.name
          });
        }
      });
      httpObserver.observe({ entryTypes: ["http"], buffered: true });
      this.observers.push(httpObserver);
    }

    // 関数実行時間を計測するデコレータ
    static measure<T extends (...args: any[]) => any>(
      target: any,
      propertyKey: string,
      descriptor: TypedPropertyDescriptor<T>
    ): TypedPropertyDescriptor<T> {
      const originalMethod = descriptor.value!;

      descriptor.value = function (...args: any[]) {
        const name = `${target.constructor.name}.${propertyKey}`;
        performance.mark(`${name}-start`);

        try {
          const result = originalMethod.apply(this, args);

          // Promise処理の場合
          if (result instanceof Promise) {
            return result.finally(() => {
              performance.mark(`${name}-end`);
              performance.measure(name, `${name}-start`, `${name}-end`);
            });
          }

          // 同期処理の場合
          performance.mark(`${name}-end`);
          performance.measure(name, `${name}-start`, `${name}-end`);
          return result;
        } catch (error) {
          performance.mark(`${name}-end`);
          performance.measure(name, `${name}-start`, `${name}-end`);
          throw error;
        }
      } as T;

      return descriptor;
    }

    // 手動でコード計測
    static async measureExecution<T>(name: string, fn: () => Promise<T>): Promise<T> {
      performance.mark(`${name}-start`);

      try {
        const result = await fn();
        performance.mark(`${name}-end`);
        performance.measure(name, `${name}-start`, `${name}-end`);
        return result;
      } catch (error) {
        performance.mark(`${name}-end`);
        performance.measure(name, `${name}-start`, `${name}-end`);
        throw error;
      }
    }

    disconnect(): void {
      this.observers.forEach((observer) => observer.disconnect());
    }
  }

  // 使用例
  // // クラスメソッド計測
  // class BookService {
  //   @PerformanceMonitor.measure
  //   async fetchBookInfo(isbn: string): Promise<Book> {
  //     // 実装
  //   }
  // }
  //
  // // 任意のコード計測
  // await PerformanceMonitor.measureExecution('data-processing', async () => {
  //   // 重い処理
  // });
  ```

### 1.2 モジュール間の依存関係の整理

#### 問題点

- 循環依存の可能性がある（特にtypesとconstantsの相互参照）
- モジュール同士が強く結合している
- 依存関係が明示的でない

#### 修正案

- 共通の型定義と定数を独立したモジュールに整理

  ```typescript
  // types/index.ts - 基本型定義
  export type Book = {
    /* ... */
  };

  // types/api.ts - API関連の型定義
  import { Book } from "./index";
  export type ApiResponse = {
    /* ... */
  };

  // constants/index.ts - 基本定数
  export const JOB_NAME = "Bookmeter Wished Books";

  // constants/api.ts - API関連の定数
  export const API_ENDPOINTS = {
    /* ... */
  };
  ```

- 依存性注入パターンの導入

  ```typescript
  // interfaces/scraper.ts
  export interface BookScraper {
    explore(mode: "wish" | "stacked"): Promise<BookList>;
  }

  // services/bookmeter-scraper.ts
  export class BookmeterScraper implements BookScraper {
    // 実装
  }

  // app.ts
  export class App {
    constructor(
      private scraper: BookScraper,
      private biblioService: BiblioInfoService
      // 他の依存関係
    ) {}

    async run(options: AppOptions): Promise<void> {
      // 依存関係を使用した処理
    }
  }
  ```

### 1.3 レイヤードアーキテクチャの採用

#### 問題点

- 明確なアーキテクチャパターンがない
- データフローが追跡しにくい
- テスト可能性が低い

#### 修正案

- 以下のレイヤーに分離
  - データアクセス層：外部APIとの通信、データベース操作
  - ドメイン層：ビジネスロジック、エンティティ定義
  - アプリケーション層：ユースケース、オーケストレーション
  - インフラストラクチャ層：外部サービス、永続化実装

```typescript
// domain/entities/book.ts
export class Book {
  // プロパティとドメインロジック
}

// application/use-cases/fetch-books.ts
export class FetchBooksUseCase {
  constructor(
    private bookRepository: BookRepository,
    private biblioInfoService: BiblioInfoService
  ) {}

  async execute(params: FetchBooksParams): Promise<BookList> {
    // ユースケース実行ロジック
  }
}

// infrastructure/repositories/book-repository.ts
export class BookmeterBookRepository implements BookRepository {
  constructor(private scraper: BookmeterScraper) {}

  async getBooks(mode: "wish" | "stacked"): Promise<BookList> {
    // 実装
  }
}
```

## 8. その他の改善点

### 8.1 コード標準化

#### 問題点

- コーディング規約が明確に定義されていない
- スタイルの一貫性がない（インデント、命名規則など）
- 静的解析ツールの設定が不十分

#### 修正案

- ESLint/TSLintルールの強化

  ```typescript
  // eslint.config.mjs
  export default [
    {
      files: ["**/*.ts", "**/*.tsx"],
      plugins: {
        "@typescript-eslint": tseslint.plugin
      },
      languageOptions: {
        parser: tseslint.parser,
        parserOptions: {
          project: "./tsconfig.json"
        }
      },
      rules: {
        // コード品質に関するルール
        "no-console": ["warn", { allow: ["warn", "error", "info"] }],
        "no-unused-vars": "off", // TypeScriptの方が優れているため無効化
        "@typescript-eslint/no-unused-vars": ["error", { argsIgnorePattern: "^_" }],
        "@typescript-eslint/explicit-function-return-type": ["error", { allowExpressions: true }],
        "@typescript-eslint/no-explicit-any": "warn",
        "@typescript-eslint/no-floating-promises": "error",

        // スタイルに関するルール
        "max-len": ["warn", { code: 100, ignoreStrings: true, ignoreComments: true }],
        indent: ["error", 2, { SwitchCase: 1 }],
        quotes: ["error", "single", { avoidEscape: true }],
        semi: ["error", "always"],

        // 関数型プログラミングのルール
        "prefer-const": "error",
        "no-var": "error",
        "no-param-reassign": "error",

        // 非同期処理のルール
        "@typescript-eslint/promise-function-async": "error",
        "@typescript-eslint/await-thenable": "error"
      }
    }
  ];
  ```

- Git Hooksによる自動検証

  ```json
  // package.json
  {
    "scripts": {
      "lint": "eslint . --ext .ts,.tsx",
      "lint:fix": "eslint . --ext .ts,.tsx --fix",
      "format": "prettier --write \"**/*.{ts,tsx,json,md}\"",
      "type-check": "tsc --noEmit",
      "prepare": "husky install"
    },
    "husky": {
      "hooks": {
        "pre-commit": "lint-staged",
        "pre-push": "npm run type-check"
      }
    },
    "lint-staged": {
      "*.{ts,tsx}": ["eslint --fix", "prettier --write"],
      "*.{json,md}": ["prettier --write"]
    }
  }
  ```

- プロジェクト固有のコーディング規約ドキュメント

  ```markdown
  # コーディング規約

  ## 命名規則

  - クラス: PascalCase (`BookService`)
  - インターフェース: PascalCase (`BookRepository`)
  - タイプエイリアス: PascalCase (`BookList`)
  - 変数・関数: camelCase (`fetchBookInfo`)
  - 定数: UPPER_CASE (`DEFAULT_TIMEOUT`)
  - プライベートメンバー: `_` 接頭辞 (`private _bookList`)

  ## ファイル構成

  - 1ファイルにつき1つの主要なエクスポート
  - ファイル名はエクスポートする内容に合わせる（小文字、ハイフン区切り）
  - テストファイル: `*.test.ts` または `*.spec.ts`

  ## コメント

  - 公開API/関数: JSDocコメント必須
  - 複雑なロジック: 目的と理由を説明するコメントを追加
  - TODO/FIXMEコメント: 課題番号とともに記載
  ```

### 8.2 ビルドと配布の最適化

#### 問題点

- 依存関係の管理が不十分
- ビルドプロセスが最適化されていない
- 配布パッケージサイズの考慮がない

#### 修正案

- 依存関係の最適化

  ```typescript
  // package.json
  {
    "dependencies": {
      // 本番環境で必要な依存関係のみを記載
    },
    "devDependencies": {
      // 開発時のみ必要な依存関係
    },
    "peerDependencies": {
      // プラグインなど、ホストプロジェクトが提供すべき依存関係
    },
    "engines": {
      "node": ">=16.0.0"  // 必要なNodeバージョンを明示
    }
  }
  ```

- Webpackでの最適化

  ```javascript
  // webpack.config.js
  const TerserPlugin = require("terser-webpack-plugin");
  const { BundleAnalyzerPlugin } = require("webpack-bundle-analyzer");

  module.exports = {
    mode: process.env.NODE_ENV || "development",
    entry: "./src/index.ts",
    output: {
      path: path.resolve(__dirname, "dist"),
      filename: "bundle.js",
      libraryTarget: "umd"
    },
    resolve: {
      extensions: [".ts", ".tsx", ".js"],
      alias: {
        "@": path.resolve(__dirname, "src")
      }
    },
    module: {
      rules: [
        {
          test: /\.tsx?$/,
          use: [
            {
              loader: "ts-loader",
              options: {
                transpileOnly: process.env.NODE_ENV === "production"
              }
            }
          ],
          exclude: /node_modules/
        }
      ]
    },
    optimization: {
      minimize: process.env.NODE_ENV === "production",
      minimizer: [
        new TerserPlugin({
          terserOptions: {
            compress: {
              drop_console: true
            }
          }
        })
      ],
      splitChunks: {
        chunks: "all",
        cacheGroups: {
          vendors: {
            test: /[\\/]node_modules[\\/]/,
            name: "vendors",
            chunks: "all"
          }
        }
      }
    },
    plugins: [...(process.env.ANALYZE ? [new BundleAnalyzerPlugin()] : [])]
  };
  ```

- CI/CDパイプラインの導入

  ```yaml
  # .github/workflows/main.yml
  name: CI/CD

  on:
    push:
      branches: [main]
    pull_request:
      branches: [main]

  jobs:
    test:
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v3
        - name: Setup Node.js
          uses: actions/setup-node@v3
          with:
            node-version: "16"
            cache: "npm"
        - name: Install dependencies
          run: npm ci
        - name: Lint
          run: npm run lint
        - name: Type check
          run: npm run type-check
        - name: Run tests
          run: npm test

    build:
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      needs: test
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v3
        - name: Setup Node.js
          uses: actions/setup-node@v3
          with:
            node-version: "16"
            cache: "npm"
        - name: Install dependencies
          run: npm ci
        - name: Build
          run: npm run build
        - name: Upload build artifacts
          uses: actions/upload-artifact@v3
          with:
            name: build
            path: dist
  ```

### 8.3 ユーザビリティ向上

#### 問題点

- CLIインターフェースが使いにくい
- 処理の進捗状況が分かりにくい
- ヘルプドキュメントが不足している

#### 修正案

- CLIインターフェースの改善

  ```typescript
  // cli/index.ts
  import yargs from "yargs";
  import { hideBin } from "yargs/helpers";
  import { main } from "../src/index";
  import { logger } from "../src/utils/logger";

  const argv = yargs(hideBin(process.argv))
    .usage("Usage: $0 <command> [options]")
    .command("wish [userId]", "Fetch wish list books", (yargs) => {
      return yargs.positional("userId", {
        describe: "Bookmeter user ID",
        type: "string"
      });
    })
    .command("stacked [userId]", "Fetch stacked books", (yargs) => {
      return yargs.positional("userId", {
        describe: "Bookmeter user ID",
        type: "string"
      });
    })
    .option("no-login", {
      describe: "Skip login process",
      type: "boolean",
      default: false
    })
    .option("no-remote", {
      describe: "Skip checking remote data",
      type: "boolean",
      default: false
    })
    .option("skip-biblio", {
      describe: "Skip fetching bibliographic information",
      type: "boolean",
      default: false
    })
    .option("output-dir", {
      describe: "Directory to save output files",
      type: "string"
    })
    .option("verbose", {
      alias: "v",
      describe: "Run with verbose logging",
      type: "boolean",
      default: false
    })
    .help("h")
    .alias("h", "help")
    .example("$0 wish", "Fetch wish list for default user")
    .example("$0 stacked 1234567", "Fetch stacked books for user 1234567")
    .epilog("For more information, visit https://github.com/user/repo")
    .parse();

  if (argv.verbose) {
    logger.level = "debug";
  }

  if (argv._.includes("wish")) {
    main({
      mode: "wish",
      userId: argv.userId as string,
      doLogin: !argv["no-login"],
      noRemoteCheck: argv["no-remote"],
      skipFetchingBiblioInfo: argv["skip-biblio"],
      outputFilePath: argv["output-dir"]
        ? {
            wish: `${argv["output-dir"]}/bookmeter_wish_books.csv`,
            stacked: `${argv["output-dir"]}/bookmeter_stacked_books.csv`
          }
        : null
    }).catch((error) => {
      logger.error("Application failed:", error);
      process.exit(1);
    });
  } else if (argv._.includes("stacked")) {
    main({
      mode: "stacked",
      userId: argv.userId as string,
      doLogin: !argv["no-login"],
      noRemoteCheck: argv["no-remote"],
      skipFetchingBiblioInfo: argv["skip-biblio"],
      outputFilePath: argv["output-dir"]
        ? {
            wish: `${argv["output-dir"]}/bookmeter_wish_books.csv`,
            stacked: `${argv["output-dir"]}/bookmeter_stacked_books.csv`
          }
        : null
    }).catch((error) => {
      logger.error("Application failed:", error);
      process.exit(1);
    });
  } else {
    yargs.showHelp();
    process.exit(1);
  }
  ```

- 進捗表示の改善

  ```typescript
  // utils/progress.ts
  import cliProgress from "cli-progress";
  import colors from "ansi-colors";
  import { EventEmitter } from "events";

  export class ProgressTracker extends EventEmitter {
    private bar: cliProgress.SingleBar;
    private total: number;
    private current = 0;
    private isEnabled: boolean;

    constructor(total: number, options: { enabled?: boolean; title?: string } = {}) {
      super();
      this.total = total;
      this.isEnabled = options.enabled ?? process.stdout.isTTY;

      this.bar = new cliProgress.SingleBar({
        format: `${options.title || "Progress"} |${colors.cyan("{bar}")}| {percentage}% | {value}/{total} | {status}`,
        barCompleteChar: "\u2588",
        barIncompleteChar: "\u2591",
        hideCursor: true,
        clearOnComplete: false,
        stopOnComplete: true
      });

      if (this.isEnabled && this.total > 0) {
        this.bar.start(this.total, 0, { status: "Starting..." });
      }
    }

    update(increment = 1, status?: string): void {
      this.current += increment;

      if (this.isEnabled) {
        this.bar.update(this.current, { status: status || "Processing..." });
      }

      this.emit("progress", {
        current: this.current,
        total: this.total,
        percentage: Math.round((this.current / this.total) * 100),
        status
      });
    }

    complete(message = "Complete"): void {
      if (this.isEnabled) {
        this.bar.update(this.total, { status: message });
        this.bar.stop();
      }

      this.emit("complete", { message });
    }
  }

  // 使用例
  // const progress = new ProgressTracker(bookUrls.length, { title: 'Fetching books' });
  // for (const url of bookUrls) {
  //   await fetchBook(url);
  //   progress.update(1, `Fetched ${url}`);
  // }
  // progress.complete('All books fetched successfully');
  ```

- インタラクティブモードの追加

  ```typescript
  // cli/interactive.ts
  import inquirer from "inquirer";
  import { main } from "../src/index";
  import { logger } from "../src/utils/logger";

  export async function runInteractiveMode(): Promise<void> {
    try {
      const answers = await inquirer.prompt([
        {
          type: "list",
          name: "mode",
          message: "どのリストを取得しますか？",
          choices: [
            { name: "読みたい本リスト", value: "wish" },
            { name: "積読本リスト", value: "stacked" }
          ]
        },
        {
          type: "input",
          name: "userId",
          message: "ユーザーIDを入力してください（デフォルトは自分のID）:",
          default: ""
        },
        {
          type: "confirm",
          name: "doLogin",
          message: "ログインしますか？",
          default: true
        },
        {
          type: "confirm",
          name: "fetchBiblio",
          message: "書誌情報を取得しますか？",
          default: true
        },
        {
          type: "confirm",
          name: "verbose",
          message: "詳細なログを表示しますか？",
          default: false
        }
      ]);

      if (answers.verbose) {
        logger.level = "debug";
      }

      await main({
        mode: answers.mode,
        userId: answers.userId || undefined,
        doLogin: answers.doLogin,
        skipFetchingBiblioInfo: !answers.fetchBiblio,
        noRemoteCheck: false
      });

      console.log("処理が完了しました！");
    } catch (error) {
      logger.error("インタラクティブモードでエラーが発生しました:", error);
      process.exit(1);
    }
  }

  // 使用例
  // if (process.argv.includes('--interactive') || process.argv.includes('-i')) {
  //   runInteractiveMode();
  // } else {
  //   // 通常のCLI処理
  // }
  ```

これで、コードベースの品質を大幅に向上させ、プロジェクトの保守性と拡張性を高めることができるでしょう。特に、コード標準化とユーザビリティの向上は、他の開発者の参加を容易にし、プロジェクトの長期的な健全性に貢献します。
