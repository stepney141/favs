# bookmeter プロジェクト ソースコードレビュー (2025-05-02)

## 1. 全体構成とアーキテクチャ

### 1.1. `index.ts` の責務過多

`index.ts` の `main` 関数が、アプリケーションの起動から終了までのほぼ全ての主要な処理フロー（Puppeteerの初期化、ログイン、Bookmeterからのデータ取得、差分比較、各種APIからの書誌情報取得、紀伊國屋書店からの説明文取得、SQLiteへの保存、CSVへのエクスポート、Firebaseへのアップロード）を直接制御しています。これにより、`index.ts` が非常に多くの責務を負い、肥大化しています。

**具体的な問題点:**

- **単一責任の原則違反:** `main` 関数が多くの異なる関心事を扱っており、変更に対する影響範囲が広くなっています。例えば、書誌情報取得ロジックの変更が、Puppeteerの初期化コードと同じファイル内にあるため、関連性の低いコードが混在しています。
- **テスト容易性の低下:** `main` 関数全体をユニットテストすることが困難です。多くの外部依存（ファイルシステム、ネットワーク、DB、Puppeteer）を持つため、モック化が複雑になります。
- **可読性と保守性の低下:** 関数が長大になり、処理の流れを追うのが難しくなっています。

**改善提案:**

- 処理の各ステップ（例: データ取得、書誌情報取得、データ永続化）を独立したモジュールや関数に分割し、`index.ts` はそれらを呼び出して全体のフローを制御するオーケストレーターとしての役割に専念させるべきです。
- 設定値の読み込みや Puppeteer の初期化のようなセットアップ処理は、専用の関数やモジュールに分離します。
- コマンドライン引数のパースとバリデーションも、専用の関数に切り出します。

### 1.2. モジュール間の密結合

各モジュール（`index.ts`, `bookmaker.ts`, `fetchers.ts`, `sqlite.ts`, `kinokuniya.ts` など）が相互に強く依存しあっています。

**具体的な問題点:**

- **`index.ts` の広範な依存:** 上述の通り、`index.ts` が多くの下位モジュールに直接依存しています。
- **`kinokuniya.ts` と `sqlite.ts` の結合:** `kinokuniya.ts` が SQLite の詳細（`checkBookDescriptionExists`, `updateDescription`）を知っており、直接呼び出しています。これは関心の分離の原則に反します。`kinokuniya.ts` は説明文の取得に専念し、取得したデータを返すだけに留め、DBへの保存は上位の層（例: `index.ts` やデータ永続化層）が担当するべきです。
- **副作用の伝播:** あるモジュールが持つ副作用（例: `fetchers.ts` の API 呼び出し、`bookmaker.ts` の Puppeteer 操作）が、呼び出し元のモジュールに影響を与えやすく、コードの予測可能性を低下させています。

**改善提案:**

- 依存性逆転の原則 (DIP) を適用し、具象クラスではなくインターフェースや抽象型に依存するようにします。例えば、`kinokuniya.ts` が直接 `sqlite.ts` を呼ぶ代わりに、抽象的な「書籍情報更新インターフェース」のようなものを介して処理を依頼する形にします。
- 各モジュールの責務を明確にし、他のモジュールの内部実装の詳細を知らなくても利用できるようにインターフェースを設計します。

### 1.3. 副作用の管理不足

アプリケーション全体で副作用（コンソール出力、ファイルI/O、DB操作、外部API呼び出し、Puppeteerによるブラウザ操作）が広く分散しており、純粋な計算処理と副作用を伴う処理が明確に分離されていません。

**具体的な問題点:**

- **テストの困難さ:** 副作用を持つ関数はユニットテストが難しくなります。
- **コードの予測不可能性:** 副作用がどこで発生するかわかりにくいと、コードの挙動を理解し、デバッグすることが難しくなります。
- **関数型原則との乖離:** 関数型プログラミングでは、副作用を可能な限り局所化し、管理下に置くことが推奨されます。

**改善提案:**

- 副作用を持つ処理（I/O操作、API呼び出しなど）を、純粋なデータ変換処理から分離します。例えば、APIからデータを取得する関数と、取得したデータを整形する関数を分けます。
- 副作用を伴うアクションを実行する層と、ビジネスロジックを実行する層を分離するアーキテクチャ（例: Hexagonal Architecture, Clean Architecture）の導入を検討します。
- `fp-ts` などのライブラリを利用して、`IO` や `Task` モナドを用いて副作用を明示的に扱うことを検討します。

### 1.4. 状態管理の一貫性欠如

`Bookmaker` クラスは内部状態を持つオブジェクト指向的な設計ですが、`fetchers.ts` や `index.ts` の `main` 関数内では、変数の再代入による手続き的な状態管理が行われています。プロジェクト全体で状態管理の方針に一貫性がありません。

**改善提案:**

- プロジェクト全体で状態管理のアプローチ（オブジェクト指向、関数型（不変性重視）など）を統一します。
- 関数型アプローチを採用する場合、`Map` や配列の更新にはイミュータブルな操作（例: スプレッド構文、`fp-ts` の関数）を使用し、変数の再代入を避けます。

### 1.5. 設定と依存性の注入

APIキーやログイン情報などの設定値や、Puppeteer のインスタンスのような依存オブジェクトの管理方法が場当たり的です。

**具体的な問題点:**

- **設定値のグローバルアクセス:** `.env` から読み込んだ値がグローバルスコープに近い形で利用されており、どこでどの設定が使われているか追跡しにくいです。
- **手動での依存性注入:** Puppeteer のインスタンスなどが手動で関数やコンストラクタに渡されており、依存関係が複雑になると管理が煩雑になります。

**改善提案:**

- 設定値を一元管理する設定オブジェクトやクラスを作成し、必要な箇所に明示的に渡します。
- 依存性注入（DI）コンテナの導入を検討し、オブジェクトの生成と依存関係の解決を自動化します。

## 2. 関数型プログラミング原則

### 2.1. 不変性の欠如

多くの箇所で `Map` やオブジェクトが直接変更されています。関数型プログラミングでは、データ構造の不変性を保つことが推奨されます。

**具体的な問題点:**

- **`Bookmaker` クラス:** `#wishBookList` や `#stackedBookList` といった内部状態の `Map` を直接 `set` メソッドで変更しています (`#getWishBooks`, `#getStackedBooks`)。また、`#hasChanges` フラグも直接変更されています。
- **`fetchers.ts`:** `fetchBiblioInfo` 関数内で `booklist.set(v.bookmeterUrl, v.updatedBook)` のように、引数として受け取った `booklist` を直接変更しています。`fetchSingleRequestAPIs` 内でも `updatedSearchState.book = ciniiStatus.book` のようにオブジェクトのプロパティを再代入しています。
- **`kinokuniya.ts`:** `processBookList` 関数内で `book.description = ...` のように、ループ内で `bookList` の要素を直接変更しています。
- **`index.ts`:** `main` 関数内で `updatedBooklist = await fetchBiblioInfo(...)` のように変数が再代入されています。

**改善提案:**

- `Map` やオブジェクトを更新する際は、元のデータを変更せず、新しいデータ構造を返すようにします。例えば、`Map` の更新には新しい `Map` を生成する、オブジェクトの更新にはスプレッド構文 (`{ ...original, property: newValue }`) を使用します。
- クラスの状態変更は、状態を変更した新しいインスタンスを返すメソッドを通じて行うようにします（例: `setHasChanges` が新しい `Bookmaker` インスタンスを返す）。
- `fp-ts` の `ReadonlyMap` や `ReadonlyRecord`、イミュータブルなデータ構造を扱うライブラリ（例: `immer`）の利用を検討します。

### 2.2. 副作用と純粋関数の混在

副作用を持つ処理（APIリクエスト、DBアクセス、ファイルI/O、コンソール出力、Puppeteer操作）と、純粋なデータ変換処理が同じ関数内に混在しています。

**具体的な問題点:**

- **`fetchers.ts` の各 fetch 関数:** APIリクエスト（副作用）と、レスポンスデータの整形（純粋な処理に近い）が混在しています。エラー時のコンソール出力（副作用）も含まれています。
- **`bookmaker.ts` のメソッド:** Puppeteer によるブラウザ操作（副作用）と、取得したデータの加工（純粋な処理に近い）が混在しています。コンソール出力も含まれています。
- **`sqlite.ts` の関数:** DB操作（副作用）と、データのマッピング（純粋な処理に近い）が混在しています。
- **`index.ts` の `main` 関数:** 全ての処理が副作用を持つか、副作用を持つ関数を呼び出しています。

**改善提案:**

- 副作用（特にI/Oバウンドな処理）を実行する関数と、純粋なデータ変換を行う関数を明確に分離します。
- APIクライアントやDBアクセスのための薄いラッパーを作成し、副作用をそこに閉じ込めます。
- ビジネスロジックは、可能な限り純粋関数で実装し、テスト容易性を高めます。
- `fp-ts` の `Task` や `IO` を使用して、副作用を型システムで明示的に表現し、実行タイミングを制御します。

### 2.3. ポイントフリースタイルの不足

関数の組み合わせや合成があまり活用されておらず、中間変数を多用した手続き的な記述が目立ちます。

**改善提案:**

- `fp-ts/function` の `pipe` や `flow` を活用し、データ変換のパイプラインを宣言的に記述します。これにより、中間変数を減らし、コードの可読性を向上させることができます。
- 小さな純粋関数を多数作成し、それらを組み合わせてより複雑な処理を実現します。

## 3. エラーハンドリングと堅牢性

### 3.1. エラー処理の不統一

エラーハンドリングの方法が箇所によって異なります。`try...catch` ブロックが使われている箇所もあれば、Axios のエラーを個別にチェックしている箇所 (`isAxiosError`)、あるいはエラーをそのまま上位にスローしている箇所もあります。

**具体的な問題点:**

- **`index.ts` の `main` 関数:** 最上位で `try...catch` を使用し、Axiosエラーとそれ以外のエラーで処理を分けていますが、具体的なエラーの種類に応じたリカバリー戦略が不足しています。`process.exit(1)` でプロセスを終了させていますが、これが常に適切な挙動とは限りません。
- **`fetchers.ts`:** 各API呼び出し関数内で `try...catch` を使用し、エラー発生時にはコンソールにログを出力し、特定の `BookSearchState`（例: `Not_found_in_XXX`, `XXX_API_Error`）を返しています。これは一貫性がありますが、エラー情報を構造化して返す方がより良い場合があります。`logAxiosError` 関数は Axios エラーの詳細を出力しますが、それ以外のエラーは `Unknown error` として扱われます。
- **`sqlite.ts`:** `saveBookListToDatabase` では `try...catch...finally` を使用し、エラー時にロールバックを行っていますが、他の関数（例: `loadBookListFromDatabase`）ではエラーをそのままスローしています。
- **`bookmaker.ts`:** `login` や `explore` メソッド内で発生しうる Puppeteer 関連のエラー（タイムアウト、要素が見つからないなど）に対する明示的な `try...catch` が不足している箇所があります。

**改善提案:**

- エラーハンドリング戦略を統一します。例えば、リカバリー可能なエラーと不可能なエラーを区別し、それぞれに応じた処理（リトライ、デフォルト値の使用、エラーの集約と報告、プロセスの正常終了/異常終了）を定義します。
- `fp-ts` の `Either` や `TaskEither` を使用して、成功と失敗のパスを型レベルで明示的に表現し、エラー処理を強制します。これにより、`try...catch` の使用を減らし、エラーが見逃されるリスクを低減できます。
- カスタムエラークラスを定義し、エラーの種類（ネットワークエラー、APIエラー、データパースエラー、DBエラーなど）を区別できるようにします。

### 3.2. APIエラー時のフォールバック処理の限定性

`fetchers.ts` では、APIエラーが発生した場合に `Not_found_in_XXX` や `XXX_API_Error` といったステータス文字列を `Book` オブジェクトの各プロパティに設定して返しています。

**具体的な問題点:**

- **情報の損失:** エラーが発生したという事実以外の情報（具体的なエラーメッセージ、ステータスコードなど）が失われています。
- **後続処理の複雑化:** 呼び出し元は、各プロパティがエラーを示す文字列かどうかをチェックする必要があり、コードが冗長になります。
- **型の不整合:** `Book` 型のプロパティにエラーを示す文字列が入るのは、型の意味合いとして不自然です。

**改善提案:**

- API呼び出しの結果を `Either<ApiError, BookInfo>` のような型で表現します。`ApiError` にはエラーの種類、メッセージ、ステータスコードなどの詳細情報を含めます。
- エラーが発生した場合、呼び出し元がエラーの種類に応じて適切なフォールバック処理（他のAPIを試す、デフォルト値を使う、処理をスキップするなど）を行えるように、構造化されたエラー情報を渡します。

### 3.3. Puppeteer 操作の堅牢性

Puppeteer を使用したスクレイピングは、ウェブサイトの構造変更やネットワークの問題により失敗しやすいです。

**具体的な問題点:**

- **タイムアウト:** `page.waitForNavigation`, `waitForXPath` などでタイムアウトが発生した場合のリカバリー処理が限定的です。
- **要素の不在:** XPath で要素が見つからなかった場合の処理が、暗黙的なエラーや予期せぬ挙動につながる可能性があります（例: `handle[0]` が `undefined` になる）。
- **ログイン失敗:** `bookmaker.ts` の `login` メソッドでログインに失敗した場合のハンドリングが不十分です。
- **リクエストインターセプト:** 画像リクエストを中断していますが、他の不要なリソース（CSS、一部のJS）も中断することで、パフォーマンスと安定性を向上できる可能性があります。

**改善提案:**

- `waitForXPath` や要素へのアクセスを行う前に、要素が存在するかどうかをチェックする処理を追加します。
- タイムアウトや要素が見つからない場合に、リトライ処理や代替手段（別のセレクタを試すなど）を実装します。
- ログイン成功/失敗を明確に判定し、失敗した場合にエラーをスローするか、適切な状態を返すようにします。
- リクエストインターセプトの対象をより広げ、不要なリソースの読み込みを削減します。
- スクレイピング対象のページの構造変更を検知する仕組み（例: 主要な要素の存在確認）を導入し、変更があった場合に通知または処理を停止するようにします。

### 3.4. 想定外のデータ形式への対応

外部APIのレスポンスやスクレイピング結果が、想定と異なる形式で返ってくる可能性があります。

**具体的な問題点:**

- **型アサーションの多用:** `as` キーワードによる型アサーションが散見されます（例: `matchASIN(amzn_raw) as ISBN10 | ASIN`）。これは、実際のデータが型と一致しない場合にランタイムエラーを引き起こす可能性があります。
- **レスポンス構造の決め打ち:** APIレスポンスの特定のプロパティが存在することを前提としたコード（例: `response.data["@graph"][0]`）は、レスポンス構造が変わるとエラーになります。

**改善提案:**

- `io-ts` や `zod` などのランタイム型検証ライブラリを使用して、外部データの形式をバリデーションし、期待する型に安全にデコードします。これにより、型アサーションを排除し、不正なデータ形式に対する堅牢性を高めます。
- APIレスポンスのプロパティにアクセスする際は、オプショナルチェイニング (`?.`) やデフォルト値 (`??`) を適切に使用し、プロパティが存在しない場合のエラーを防ぎます。

## 4. コードの重複

いくつかの箇所で類似したコードパターンが繰り返されています。

**具体的な問題点:**

- **Puppeteer の初期化とリクエストインターセプト:** `index.ts` の `main` 関数、`bookmaker.ts` の `login` と `explore` メソッド、`kinokuniya.ts` の `crawlKinokuniya` 関数内で、Puppeteer の起動 (`puppeteer.launch`) やリクエストインターセプトの設定が繰り返し記述されています。
- **Bookmeter ページのスキャンロジック:** `bookmaker.ts` の `#getWishBooks` (ログイン時/非ログイン時) と `#getStackedBooks` で、ページネーションを伴う書籍リストのスキャンロジックに類似点が見られます。特に非ログイン時の `scanEachBook` 呼び出しループは `#getStackedBooks` とほぼ同じです。
- **API エラー時のフォールバック:** `fetchers.ts` の各 fetch 関数で、APIエラー時に `XXX_API_Error` や `Not_found_in_XXX` といったステータス文字列を持つ `BookSearchState` を返す処理が繰り返されています。
- **SQLite の定型処理:** `sqlite.ts` 内でデータベース接続を開閉する処理 (`open`, `db.close()`) が各関数で繰り返されています。

**改善提案:**

- Puppeteer のインスタンス生成や共通設定（リクエストインターセプトなど）を行うヘルパー関数やファクトリを作成し、共通化します。
- Bookmeter のページスキャンロジックを抽象化し、ログイン状態や対象リスト（wish/stacked）の違いをパラメータで吸収できるような共通関数を作成します。
- APIエラー時の共通処理（ログ出力、特定のエラーオブジェクト生成など）をヘルパー関数にまとめます。
- SQLite の操作をラップするクラスやモジュールを作成し、接続管理をカプセル化します。例えば、高階関数を使ってトランザクション処理を共通化するなどが考えられます。

## 5. 型安全性

TypeScript を使用していますが、型安全性が十分に活かされていない箇所があります。

**具体的な問題点:**

- **`any` 型の使用:** `.libs/utils` の `mapToArray` や `exportFile` など、型パラメータが適切に使用されていないか、`any` が暗黙的/明示的に使用されている可能性があります（コード未提供のため推測）。
- **型アサーション (`as`) の多用:** `fetchers.ts` や `utils.ts` で `as ISBN10 | ASIN` や `as NdlResponseJson` のような型アサーションが使用されています。これは、コンパイラによる型チェックを回避し、ランタイムエラーのリスクを高めます。
- **不正確な型定義:**
  - `fetchers.ts` の `bulkFetchOpenBD` では、エラー時に `BookSearchState` の各プロパティにエラー文字列を入れていますが、`Book` 型の定義と矛盾します。
  - `types.ts` の `Book` 型の `isbn_or_asin` は `ISBN10 | ASIN` となっていますが、実際には `ISBN13` も含まれる可能性があります（`convertISBN10To13` の存在から）。また、`null` や `undefined` の可能性も考慮が必要です。
  - 外部APIのレスポンス型 (`OpenBD.Response`, `NdlResponseJson`, `CiniiResponse` など）が、実際のレスポンス構造と完全に一致しているか、より厳密な検証が必要です。特に `NdlResponseJson` の `item` が単一オブジェクトか配列かは、より安全な方法で判別すべきです。
- **環境変数の非nullアサーション:** `index.ts` で `process.env.XXX!.toString()` のように非nullアサーション演算子 `!` が使われています。環境変数が未定義の場合、ランタイムエラーが発生します。

**改善提案:**

- `any` 型の使用を避け、ジェネリクスや具体的な型定義を使用します。
- 型アサーション (`as`) の代わりに、型ガード関数 (`isXxx`) やランタイム型検証ライブラリ (`io-ts`, `zod`) を使用して、型の安全性を確保します。
- 型定義をより正確にします。エラー状態は `Either` や専用の型（例: `type ApiResult = { type: 'success', data: BookInfo } | { type: 'error', error: ApiError }`）で表現します。`isbn_or_asin` の型は `ISBN10 | ISBN13 | ASIN | null | undefined` のように、取りうる全ての可能性を反映させます。
- 環境変数は、起動時に存在チェックとバリデーションを行い、失敗した場合はエラーメッセージと共にプロセスを終了させるか、デフォルト値を使用するようにします。非nullアサーションは避けます。

## 6. 可読性と保守性

コードの可読性や保守性を向上させるための改善点がいくつかあります。

**具体的な問題点:**

- **マジックナンバー/マジックストリング:**
  - `sleep` 関数に渡される待機時間（例: `sleep(1000)`, `sleep(40 * 1000)`）が直接記述されています。
  - XPath 文字列が `constants.ts` にまとめられていますが、非常に長く複雑なものもあります。
  - エラーを示すステータス文字列（`Not_found_in_XXX` など）が直接埋め込まれています。
- **命名:**
  - `bookmaker.ts` の `#getWishBooks`, `#getStackedBooks` は副作用（クラスの状態変更）を持つため、`fetchAndSetWishBooks` のような命名の方が実態を表しているかもしれません。
  - 変数名 `bkmt` や `amzn` はやや短すぎます (`bookmeterUrl`, `amazonLink` or `asin` の方が明確）。
- **コメント:** コードの意図を説明するコメントが不足している箇所や、逆に自明な処理にコメントが付いている箇所があります。特に複雑なロジックやワークアラウンドには、その理由を説明するコメントが必要です。
- **関数の長さ:** `index.ts` の `main` 関数、`fetchers.ts` の `fetchBiblioInfo` や `fetchSingleRequestAPIs`、`sqlite.ts` の `saveBookListToDatabase` など、一部の関数が長大で読みにくいです。
- **ロギング:** `console.log` と `console.error` が混在しており、ログレベルの区別や構造化がされていません。`JOB_NAME` がプレフィックスとして使われていますが、より詳細な情報（タイムスタンプ、モジュール名など）があるとデバッグが容易になります。

**改善提案:**

- マジックナンバー/マジックストリングは、意味のある名前を持つ定数として定義します（例: `const DEFAULT_API_WAIT_MS = 1500;`）。エラー文字列は Enum やユニオン型として定義します。
- 命名規則を一貫させ、変数名や関数名はその役割や内容を正確に反映するようにします。副作用を持つ関数は、そのことがわかるような動詞（`fetchAndSave`, `updateUser` など）を使います。
- 「なぜ」そのコードが必要なのかを説明するコメントを、複雑なロジック、外部仕様への依存、ワークアラウンドなどに記述します。
- 関数をより小さく、単一の責任を持つように分割します。
- `pino` や `winston` などのロギングライブラリを導入し、ログレベル、タイムスタンプ、構造化ロギング（JSON形式など）をサポートします。

## 7. ファイルごとの具体的な指摘

### 7.1. `index.ts`

*   **`main` 関数の巨大さ:** 前述の通り、関数が長大で多くの責務を持ちすぎているため、分割が必要です。
*   **オプションフラグの複雑さ:** `noRemoteCheck`, `skipBookListComparison`, `skipFetchingBiblioInfo` といったフラグが増え、条件分岐が複雑化しています。これらのフラグの組み合わせによっては意図しない動作をする可能性があります。設定オブジェクトやより明確な制御フローを検討すべきです。
*   **フォールバック処理:** 書誌情報取得や SQLite 保存に失敗した場合のフォールバックとして直接 CSV に書き出す処理がありますが、このフォールバック処理自体のエラーハンドリングが不足しています。
*   **環境変数の直接参照:** `main` 関数の冒頭で `.env` を読み込み、グローバルな `process.env` を直接参照しています。設定値を一元管理するモジュールや関数を用意し、そこから取得するように変更すべきです。

### 7.2. `bookmaker.ts`

*   **クラス設計:** `Bookmaker` クラスは Puppeteer の `browser` インスタンスを保持し、ログイン状態や取得した書籍リスト (`#wishBookList`, `#stackedBookList`, `#hasChanges`) を内部状態として管理しています。これはオブジェクト指向的なアプローチですが、状態変更の副作用がクラス内部に閉じ込められておらず、メソッド呼び出しによって外部から変更可能になっています (`setHasChanges`)。また、`explore` メソッドがモードによって異なる内部リストを更新・返却するのもやや直感的ではありません。状態管理をより明確にするか、あるいはクラスではなく関数ベースのアプローチを検討する余地があります。
*   **スクレイピングロジックの脆弱性:** XPath に強く依存しており、Bookmeter のサイト構造変更に非常に弱いです。より堅牢なセレクタ（例: data属性、ID）の使用や、構造変更への耐性を持たせる工夫が必要です。
*   **待機処理:** `sleep` による固定時間の待機が多用されています (`scanEachBook`, `#getWishBooks`)。これは必要以上に待機したり、逆に待機時間が足りなかったりする可能性があります。`page.waitForSelector` や `page.waitForFunction` など、特定の条件が満たされるまで待機する Puppeteer の機能を使う方が効率的で確実です。
*   **非ログイン時の処理:** 非ログイン時の `scanEachBook` 呼び出しは、書籍ごとにページ遷移が発生し、非常に時間がかかり、アクセス制限のリスクも高まります。可能であればログインが必須となるようにするか、APIベースのアプローチを検討すべきです。

### 7.3. `fetchers.ts`

*   **関数の責務:** 各 `fetchXXX` 関数は、APIリクエスト、レスポンスのパース、データ整形、エラーハンドリング（ログ出力含む）という複数の責務を持っています。これらを分離することで、テスト容易性や再利用性が向上します。
*   **API クライアントの抽象化:** 各 API へのリクエストロジックが直接記述されています。Axios のインスタンス生成や共通ヘッダー設定、ベースURLなどをまとめた API クライアント層を作成すると、コードが整理されます。
*   **`PromiseQueue` の利用:** `fetchBiblioInfo` で `PromiseQueue` を使って並列数を制御していますが、`fp-ts` の `Traversable` や `TaskEither` の並列実行機能 (`sequence`, `traverseArray`, `traverseSeqArray`) を使うと、より宣言的で型安全な並列処理を記述できます。
*   **数学図書館リストの取得:** `configMathlibBookList` 関数は PDF をダウンロードし、テキスト抽出して ISBN をファイルに書き出していますが、この処理は書誌情報取得のメインフローとは独立して実行可能です。別のスクリプトや事前処理として分離することを検討します。また、PDF のパース処理はエラーが発生しやすいため、より堅牢なエラーハンドリングが必要です。

### 7.4. `sqlite.ts`

*   **同期処理 (`saveBookListToDatabase`)**: 既存データとの比較・削除・挿入/置換を一連のトランザクションで行っており、複雑性が高いです。特に `description` を保持するロジックは、`INSERT OR REPLACE` と組み合わせると意図通りに動作しない可能性があります（`REPLACE` は行全体を置き換えるため）。`description` の更新は別クエリで行うか、`UPSERT` (SQLite 3.24.0+) を利用する方が安全です。
*   **接続管理:** 各関数で `open`/`close` を繰り返しており非効率です。アプリケーション起動時に接続を確立し、終了時に閉じるか、コネクションプールを利用する方がパフォーマンスが良いです。
*   **SQL インジェクション対策:** `sanitizeTableName` でテーブル名を検証していますが、パラメータ化クエリ (`?`) が適切に使用されているため、SQLインジェクションのリスクは低いと考えられます。ただし、テーブル名を動的に生成する箇所は注意が必要です。
*   **`checkBookDescriptionExists` のロジック:** `description` が `NULL` または空文字列の場合に `false` を返しますが、一度 Kinokuniya を確認して「説明文が存在しない」ことが確定した場合と、「まだ確認していない」場合を区別できていません。状態をより明確に管理する（例: `description_status: 'checked_not_found' | 'checked_found' | 'not_checked'` のようなカラムを追加する）ことを検討します。

### 7.5. `kinokuniya.ts`

*   **`sqlite.ts` への依存:** 前述の通り、`kinokuniya.ts` が直接 `sqlite.ts` の関数 (`checkBookDescriptionExists`, `updateDescription`) を呼び出しており、密結合になっています。説明文の取得とDBへの保存は分離すべきです。
*   **既存 Description の事前ロード:** `processBookList` の冒頭で既存の説明文を全てメモリにロードしていますが、書籍数が多い場合にメモリ使用量が増加する可能性があります。`checkBookDescriptionExists` をループ内で呼び出す方がメモリ効率は良いですが、DBアクセス回数は増えます。トレードオフを考慮する必要があります。
*   **エラーハンドリング:** `getBookDetails` で XPath 要素が見つからない場合の処理が不十分です。また、`processBookList` 内の `try...catch` ではエラー発生時に空文字列を保存していますが、エラーの種類に応じた処理（リトライ、スキップなど）を検討すべきです。

### 7.6. `utils.ts`

*   **`getPrevBookList` の複雑さ:** SQLite からの読み込みを試み、失敗したら CSV から読み込むというフォールバックロジックが複雑になっています。データソースを SQLite に統一し、CSV 読み込みは初回マイグレーションなどの限定的な用途に留める方がシンプルです。
*   **ISBN/ASIN 関連関数:** `isIsbn10`, `isIsbn13`, `convertISBN10To13`, `isAsin`, `matchASIN` など、ISBN/ASIN を扱う関数が `utils.ts` と `fetchers.ts` (`routeIsbn10`) に分散しています。これらは専用のモジュール（例: `isbnUtils.ts`）にまとめると見通しが良くなります。正規表現も複雑なため、テストを充実させるべきです。
*   **`getBookListDiff`:** この関数は差分検出に使われていますが、`isBookListDifferent` 関数内では `diff.latest.length > 0` のチェックしか行っていません。削除された書籍 (`diff.prev`) や変更された書籍 (`diff.same` の内容比較) を考慮しない場合、この差分検出ロジックは不完全です。

### 7.7. `types.ts`

*   **`Book` 型の肥大化:** `Book` 型に多くのプロパティ（書誌情報、OPACリンク、所蔵状況、説明文）が含まれており、関心事が混在しています。例えば、書誌情報取得前の段階では不要なプロパティも含まれています。処理の段階に応じて型を分ける（例: `RawBook`, `BookWithBiblio`, `BookWithAvailability`）ことを検討します。
*   **API レスポンス型:** 各 API のレスポンス型定義は、手動で作成されていると思われます。API 仕様から自動生成するか、`io-ts` や `zod` のスキーマ定義から型を生成する方が、正確性と保守性が向上します。
*   **Brand 型:** `ISBN10`, `ISBN13`, `ASIN` に Brand 型が使われていますが、これらの型を生成・検証する関数が不足しています。Brand 型はコンパイル時のチェックに役立ちますが、ランタイムでの保証はありません。入力値のバリデーションと組み合わせることが重要です。
